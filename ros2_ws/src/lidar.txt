sb3/sb3_PPO.py:            print('Using Vision + lidar model')
sb3/sb3_PPO.py:            print('Using standard lidar model')
sb3/sb3_SAC.py:            print('Using standard lidar model')
sb3/environments/leo_rover_env_fused.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0,
sb3/environments/leo_rover_env_fused.py:        self.lidar_points = lidar_points
sb3/environments/leo_rover_env_fused.py:        self.max_lidar_range = max_lidar_range
sb3/environments/leo_rover_env_fused.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/leo_rover_env_fused.py:        self.min_raw_lidar = 100
sb3/environments/leo_rover_env_fused.py:        # Check robot connection - but using lidar since we still need it for rewards
sb3/environments/leo_rover_env_fused.py:        # Check for lidar data since we still need it for rewards
sb3/environments/leo_rover_env_fused.py:            if len(self.lidar_data) > 0 and np.any(self.lidar_data > 0):
sb3/environments/rover_env.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/rover_env.py:        self.lidar_points = lidar_points
sb3/environments/rover_env.py:        self.max_lidar_range = max_lidar_range
sb3/environments/rover_env.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/rover_env.py:        self.min_raw_lidar = 100
sb3/environments/rover_env.py:            'lidar': spaces.Box(
sb3/environments/rover_env.py:                high=max_lidar_range,
sb3/environments/rover_env.py:                shape=(lidar_points,),
sb3/environments/rover_env.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/rover_env.py:            self.lidar_callback,
sb3/environments/rover_env.py:            'lidar': self.lidar_data,
sb3/environments/rover_env.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/rover_env.py:    def lidar_callback(self, msg):
sb3/environments/rover_env.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/rover_env.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/rover_env.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/rover_env.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/rover_env.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/rover_env.py:        #if np.any(lidar_data < 0):
sb3/environments/rover_env.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/rover_env.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/rover_env.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/rover_env.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/rover_env.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/rover_env.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/rover_env.py:        # Replace inf values with max_lidar_range
sb3/environments/rover_env.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/rover_env.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/rover_env.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/rover_env.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/rover_env.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/rover_env.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/rover_env.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/rover_env.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/rover_env.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/rover_env.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/rover_env.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/rover_env.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/rover_env.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/rover_env.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/rover_env.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/rover_env.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/rover_env.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/rover_env_vision.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/rover_env_vision.py:        self.lidar_points = lidar_points
sb3/environments/rover_env_vision.py:        self.max_lidar_range = max_lidar_range
sb3/environments/rover_env_vision.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/rover_env_vision.py:        self.min_raw_lidar = 100
sb3/environments/rover_env_vision.py:            'lidar': spaces.Box(
sb3/environments/rover_env_vision.py:                high=max_lidar_range,
sb3/environments/rover_env_vision.py:                shape=(lidar_points,),
sb3/environments/rover_env_vision.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/rover_env_vision.py:            self.lidar_callback,
sb3/environments/rover_env_vision.py:            'lidar': self.lidar_data,
sb3/environments/rover_env_vision.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/rover_env_vision.py:    def lidar_callback(self, msg):
sb3/environments/rover_env_vision.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/rover_env_vision.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/rover_env_vision.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/rover_env_vision.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/rover_env_vision.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/rover_env_vision.py:        #if np.any(lidar_data < 0):
sb3/environments/rover_env_vision.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/rover_env_vision.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/rover_env_vision.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/rover_env_vision.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/rover_env_vision.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/rover_env_vision.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/rover_env_vision.py:        # Replace inf values with max_lidar_range
sb3/environments/rover_env_vision.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/rover_env_vision.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/rover_env_vision.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/rover_env_vision.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/rover_env_vision.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/rover_env_vision.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/rover_env_vision.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/rover_env_vision.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/rover_env_vision.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/rover_env_vision.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/rover_env_vision.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/rover_env_vision.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/rover_env_vision.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/rover_env_vision.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/rover_env_vision.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/rover_env_vision.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/rover_env_vision.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_01-12.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/bak/rover_env_heading_vel_01-12.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_env_heading_vel_01-12.py:            self.lidar_callback,
sb3/environments/bak/rover_env_heading_vel_01-12.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_env_heading_vel_01-12.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        self.min_raw_lidar = 100
sb3/environments/bak/rover_env_heading_vel_01-12.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_env_heading_vel_01-12.py:                high=max_lidar_range,
sb3/environments/bak/rover_env_heading_vel_01-12.py:                shape=(lidar_points,),
sb3/environments/bak/rover_env_heading_vel_01-12.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_env_heading_vel_01-12.py:        # Calculate minimum lidar distance for collision detection
sb3/environments/bak/rover_env_heading_vel_01-12.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_heading_vel_01-12.py:    def lidar_callbackNoise(self, msg):# function needs to be double checked!!!!
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel_01-12.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel_01-12.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel_01-12.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print(f"ERROR: Downsampled wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_01-12.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/bak/rover_env_heading_vel_01-12.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/bak/rover_env_heading_vel_01-12.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #if np.any(lidar_data < 0):
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel_01-12.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_01-12.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_01-12.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel_01-12.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel_01-12.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel_01-12.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel_01-12.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_01-12.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_environment_pointnav.py:                 connection_check_timeout=30, lidar_points=16, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_pointnav.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_environment_pointnav.py:            self.lidar_callback,
sb3/environments/bak/rover_environment_pointnav.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_pointnav.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_pointnav.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_pointnav.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_pointnav.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_pointnav.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_environment_pointnav.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav.py:                #f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment_pointnav.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_pointnav.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_pointnav.py:        segment_size = len(lidar_data) // 16
sb3/environments/bak/rover_environment_pointnav.py:        reshaped_data = lidar_data[:segment_size * 16].reshape(16, segment_size)
sb3/environments/bak/rover_environment_pointnav.py:        self.lidar_data = np.mean(reshaped_data, axis=1)
sb3/environments/bak/rover_environment_pointnav.py:    def lidar_callbackOLD(self, msg):
sb3/environments/bak/rover_environment_pointnav.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_pointnav.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_pointnav.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_pointnav.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_environment_no_pose.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_no_pose.py:        self.lidar_subscriber = self.node.create_subscription(LaserScan, scan_topic,
sb3/environments/bak/rover_environment_no_pose.py:                                                            self.lidar_callback, 10)
sb3/environments/bak/rover_environment_no_pose.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_no_pose.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_no_pose.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_no_pose.py:        # [lidar_data (640), position (3), orientation (3)]
sb3/environments/bak/rover_environment_no_pose.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_no_pose.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_no_pose.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_no_pose.py:                'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_no_pose.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_no_pose.py:                f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment_no_pose.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_no_pose.py:        if self.lidar_data is None:
sb3/environments/bak/rover_environment_no_pose.py:        min_distance = np.nanmin(self.lidar_data)
sb3/environments/bak/rover_environment_no_pose.py:        lidar_ranges = self.lidar_data
sb3/environments/bak/rover_environment_no_pose.py:        num_readings = len(lidar_ranges)
sb3/environments/bak/rover_environment_no_pose.py:        right_distances = lidar_ranges[right_side_indices]
sb3/environments/bak/rover_environment_no_pose.py:        min_distance = np.min(lidar_ranges[np.isfinite(lidar_ranges)])
sb3/environments/bak/rover_environment_no_pose.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_no_pose.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_no_pose.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_no_pose.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_no_pose.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_no_pose.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_env_heading_vel_bak.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/bak/rover_env_heading_vel_bak.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_env_heading_vel_bak.py:            self.lidar_callback,
sb3/environments/bak/rover_env_heading_vel_bak.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_env_heading_vel_bak.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_bak.py:        self.min_raw_lidar = 100
sb3/environments/bak/rover_env_heading_vel_bak.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_env_heading_vel_bak.py:                high=max_lidar_range,
sb3/environments/bak/rover_env_heading_vel_bak.py:                shape=(lidar_points,),
sb3/environments/bak/rover_env_heading_vel_bak.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_env_heading_vel_bak.py:        # Calculate minimum lidar distance for collision detection
sb3/environments/bak/rover_env_heading_vel_bak.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_heading_vel_bak.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_heading_vel_bak.py:    def lidar_callbackNoise(self, msg):# function needs to be double checked!!!!
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_bak.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel_bak.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_bak.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)
sb3/environments/bak/rover_env_heading_vel_bak.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel_bak.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_bak.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel_bak.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel_bak.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel_bak.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel_bak.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel_bak.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel_bak.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel_bak.py:                print(f"ERROR: Downsampled wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel_bak.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel_bak.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_bak.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_bak.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel_bak.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/bak/rover_env_heading_vel_bak.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/bak/rover_env_heading_vel_bak.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/bak/rover_env_heading_vel_bak.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/bak/rover_env_heading_vel_bak.py:        #if np.any(lidar_data < 0):
sb3/environments/bak/rover_env_heading_vel_bak.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/bak/rover_env_heading_vel_bak.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/bak/rover_env_heading_vel_bak.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/bak/rover_env_heading_vel_bak.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel_bak.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel_bak.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel_bak.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel_bak.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel_bak.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel_bak.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel_bak.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel_bak.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel_bak.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel_bak.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel_bak.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel_bak.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel_bak.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel_bak.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel_bak.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel_bak.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_motor.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/bak/rover_motor.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_motor.py:            self.lidar_callback,
sb3/environments/bak/rover_motor.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_motor.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_motor.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_motor.py:        self.min_raw_lidar = 100
sb3/environments/bak/rover_motor.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_motor.py:                high=max_lidar_range,
sb3/environments/bak/rover_motor.py:                shape=(lidar_points,),
sb3/environments/bak/rover_motor.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_motor.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_motor.py:    def lidar_callbackNoise(self, msg):# function needs to be double checked!!!!
sb3/environments/bak/rover_motor.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_motor.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_motor.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_motor.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_motor.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_motor.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_motor.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)
sb3/environments/bak/rover_motor.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_motor.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_motor.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_motor.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_motor.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_motor.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_motor.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_motor.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_motor.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_motor.py:                print(f"ERROR: Downsampled wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_motor.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_motor.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_motor.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_motor.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_motor.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_motor.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/bak/rover_motor.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/bak/rover_motor.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/bak/rover_motor.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/bak/rover_motor.py:        #if np.any(lidar_data < 0):
sb3/environments/bak/rover_motor.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/bak/rover_motor.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/bak/rover_motor.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/bak/rover_motor.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_motor.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_motor.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_motor.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_motor.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/bak/rover_motor.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_motor.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_motor.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_motor.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_motor.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_motor.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_motor.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_motor.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_motor.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_motor.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_motor.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_motor.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_motor.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_motor.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_env_pointnav_motor.py:                 connection_check_timeout=30, lidar_points=16, max_lidar_range=12.0):
sb3/environments/bak/rover_env_pointnav_motor.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_env_pointnav_motor.py:            self.lidar_callback,
sb3/environments/bak/rover_env_pointnav_motor.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_env_pointnav_motor.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_env_pointnav_motor.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_env_pointnav_motor.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_env_pointnav_motor.py:                high=max_lidar_range,
sb3/environments/bak/rover_env_pointnav_motor.py:                shape=(lidar_points,),
sb3/environments/bak/rover_env_pointnav_motor.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_pointnav_motor.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_env_pointnav_motor.py:                #f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_env_pointnav_motor.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_env_pointnav_motor.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_env_pointnav_motor.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_pointnav_motor.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_pointnav_motor.py:        segment_size = len(lidar_data) // 16
sb3/environments/bak/rover_env_pointnav_motor.py:        reshaped_data = lidar_data[:segment_size * 16].reshape(16, segment_size)
sb3/environments/bak/rover_env_pointnav_motor.py:        self.lidar_data = np.mean(reshaped_data, axis=1)
sb3/environments/bak/rover_env_pointnav_motor.py:    def lidar_callbackOLD(self, msg):
sb3/environments/bak/rover_env_pointnav_motor.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_pointnav_motor.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_pointnav_motor.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_pointnav_motor.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_env_pointnav_motor.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_environment_pointnav_11_23.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_pointnav_11_23.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_environment_pointnav_11_23.py:            self.lidar_callback,
sb3/environments/bak/rover_environment_pointnav_11_23.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_pointnav_11_23.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_pointnav_11_23.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav_11_23.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_pointnav_11_23.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_pointnav_11_23.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_pointnav_11_23.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_environment_pointnav_11_23.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav_11_23.py:                #f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment_pointnav_11_23.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav_11_23.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_pointnav_11_23.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav_11_23.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_pointnav_11_23.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_pointnav_11_23.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_pointnav_11_23.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_env_heading_vel.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/bak/rover_env_heading_vel.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_env_heading_vel.py:            self.lidar_callback,
sb3/environments/bak/rover_env_heading_vel.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_env_heading_vel.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel.py:        self.min_raw_lidar = 100
sb3/environments/bak/rover_env_heading_vel.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_env_heading_vel.py:                high=max_lidar_range,
sb3/environments/bak/rover_env_heading_vel.py:                shape=(lidar_points,),
sb3/environments/bak/rover_env_heading_vel.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_env_heading_vel.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_heading_vel.py:        # Calculate minimum lidar distance for collision detection
sb3/environments/bak/rover_env_heading_vel.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_env_heading_vel.py:    def lidar_callbackNoise(self, msg):# function needs to be double checked!!!!
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)
sb3/environments/bak/rover_env_heading_vel.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel.py:                print(f"ERROR: Downsampled wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_env_heading_vel.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/bak/rover_env_heading_vel.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/bak/rover_env_heading_vel.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/bak/rover_env_heading_vel.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/bak/rover_env_heading_vel.py:        #if np.any(lidar_data < 0):
sb3/environments/bak/rover_env_heading_vel.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/bak/rover_env_heading_vel.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/bak/rover_env_heading_vel.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/bak/rover_env_heading_vel.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/bak/rover_env_heading_vel.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/bak/rover_env_heading_vel.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        # Replace inf values with max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/bak/rover_env_heading_vel.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/bak/rover_env_heading_vel.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/bak/rover_env_heading_vel.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/bak/rover_env_heading_vel.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_env_heading_vel.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/bak/rover_env_heading_vel.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/bak/rover_env_heading_vel.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/bak/rover_env_heading_vel.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/bak/rover_env_heading_vel.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/bak/rover_env_heading_vel.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/bak/rover_env_heading_vel.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/bak/rover_env_heading_vel.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/bak/rover_env_heading_vel.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/bak/rover_env_heading_vel.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/bak/rover_environment_wall.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_wall.py:        self.lidar_subscriber = self.node.create_subscription(LaserScan, scan_topic,
sb3/environments/bak/rover_environment_wall.py:                                                            self.lidar_callback, 10)
sb3/environments/bak/rover_environment_wall.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_wall.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_wall.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_wall.py:        # [lidar_data (640), position (3), orientation (3)]
sb3/environments/bak/rover_environment_wall.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_wall.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_wall.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_wall.py:            self.lidar_data = np.random.uniform(0.1, self.max_lidar_range,
sb3/environments/bak/rover_environment_wall.py:                                              self.lidar_points).astype(np.float32)
sb3/environments/bak/rover_environment_wall.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_wall.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_wall.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_wall.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_wall.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_wall.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_wall.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_wall.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_environment_wall.py:        if self.lidar_data is None:
sb3/environments/bak/rover_environment_wall.py:        min_distance = np.nanmin(self.lidar_data)
sb3/environments/bak/rover_environment_wall.py:        lidar_ranges = self.lidar_data
sb3/environments/bak/rover_environment_wall.py:        num_readings = len(lidar_ranges)
sb3/environments/bak/rover_environment_wall.py:        right_distances = lidar_ranges[right_side_indices]
sb3/environments/bak/rover_environment_wall.py:        min_distance = np.min(lidar_ranges[np.isfinite(lidar_ranges)])
sb3/environments/bak/rover_environment_wall.py:        lidar_ranges = self.lidar_data
sb3/environments/bak/rover_environment_wall.py:        num_readings = len(lidar_ranges)
sb3/environments/bak/rover_environment_wall.py:        right_distances = lidar_ranges[right_side_indices]
sb3/environments/bak/rover_environment_wall.py:        max_error = lidar_ranges[np.isfinite(lidar_ranges)].max() - desired_distance
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:            self.lidar_callback,
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:                #f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_pointnav_Nov16_1555.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_environment_pose.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment_pose.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/bak/rover_environment_pose.py:            self.lidar_callback,
sb3/environments/bak/rover_environment_pose.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment_pose.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment_pose.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment_pose.py:        # [lidar_data (640), position (3), orientation (3)]
sb3/environments/bak/rover_environment_pose.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment_pose.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment_pose.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment_pose.py:                'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pose.py:        min_distance = np.min(lidar_ranges[np.isfinite(lidar_ranges)])
sb3/environments/bak/rover_environment_pose.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pose.py:                #f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment_pose.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment_pose.py:        if self.lidar_data is None:
sb3/environments/bak/rover_environment_pose.py:        min_distance = np.nanmin(self.lidar_data)
sb3/environments/bak/rover_environment_pose.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment_pose.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment_pose.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment_pose.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment_pose.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment_pose.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover_environment.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover_environment.py:        self.lidar_subscriber = self.node.create_subscription(LaserScan, scan_topic,
sb3/environments/bak/rover_environment.py:                                                            self.lidar_callback, 10)
sb3/environments/bak/rover_environment.py:        self.lidar_points = lidar_points
sb3/environments/bak/rover_environment.py:        self.max_lidar_range = max_lidar_range
sb3/environments/bak/rover_environment.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/bak/rover_environment.py:        # [lidar_data (640), position (3), orientation (3)]
sb3/environments/bak/rover_environment.py:            'lidar': spaces.Box(
sb3/environments/bak/rover_environment.py:                high=max_lidar_range,
sb3/environments/bak/rover_environment.py:                shape=(lidar_points,),
sb3/environments/bak/rover_environment.py:                'lidar': self.lidar_data,
sb3/environments/bak/rover_environment.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment.py:                f"min lidar: {round(np.nanmin(self.lidar_data),3)}   Yaw: {round(self.current_yaw,3)},  "
sb3/environments/bak/rover_environment.py:            'lidar': self.lidar_data,
sb3/environments/bak/rover_environment.py:        if self.lidar_data is None:
sb3/environments/bak/rover_environment.py:        min_distance = np.nanmin(self.lidar_data)
sb3/environments/bak/rover_environment.py:        lidar_ranges = self.lidar_data
sb3/environments/bak/rover_environment.py:        num_readings = len(lidar_ranges)
sb3/environments/bak/rover_environment.py:        right_distances = lidar_ranges[right_side_indices]
sb3/environments/bak/rover_environment.py:        min_distance = np.min(lidar_ranges[np.isfinite(lidar_ranges)])
sb3/environments/bak/rover_environment.py:    def lidar_callback(self, msg):
sb3/environments/bak/rover_environment.py:        lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/bak/rover_environment.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/bak/rover_environment.py:        if len(lidar_data) != self.lidar_points:
sb3/environments/bak/rover_environment.py:            lidar_data = np.resize(lidar_data, (self.lidar_points,))
sb3/environments/bak/rover_environment.py:        self.lidar_data = lidar_data
sb3/environments/bak/rover-env-reset.py:                 connection_check_timeout=30, lidar_points=640, max_lidar_range=12.0):
sb3/environments/bak/rover-env-reset.py:        self.lidar_subscriber = self.node.create_subscription(LaserScan, scan_topic,
sb3/environments/bak/rover-env-reset.py:                                                            self.lidar_callback, 10)
sb3/environments/bak/rover-env-reset.py:                'lidar': self.lidar_data,
sb3/environments/bak/rover-env-reset.py:            'lidar': self.lidar_data,
sb3/environments/discrete_rover_env_fused.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0,
sb3/environments/discrete_rover_env_fused.py:        self.lidar_points = lidar_points
sb3/environments/discrete_rover_env_fused.py:        self.max_lidar_range = max_lidar_range
sb3/environments/discrete_rover_env_fused.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/discrete_rover_env_fused.py:        self.min_raw_lidar = 100
sb3/environments/discrete_rover_env_fused.py:        # Check robot connection - but using lidar since we still need it for rewards
sb3/environments/discrete_rover_env_fused.py:        # Check for lidar data since we still need it for rewards
sb3/environments/discrete_rover_env_fused.py:            if len(self.lidar_data) > 0 and np.any(self.lidar_data > 0):
sb3/environments/rover_env_fused.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0,
sb3/environments/rover_env_fused.py:        self.lidar_points = lidar_points
sb3/environments/rover_env_fused.py:        self.max_lidar_range = max_lidar_range
sb3/environments/rover_env_fused.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/rover_env_fused.py:        self.min_raw_lidar = 100
sb3/environments/rover_env_fused.py:        # Check robot connection - but using lidar since we still need it for rewards
sb3/environments/rover_env_fused.py:        # Keep lidar subscriber for reward calculation
sb3/environments/rover_env_fused.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/rover_env_fused.py:            self.lidar_callback,
sb3/environments/rover_env_fused.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/rover_env_fused.py:        if False:# no lidar on leo  min_distance < collision_threshold:
sb3/environments/rover_env_fused.py:    def lidar_callback(self, msg):
sb3/environments/rover_env_fused.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/rover_env_fused.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/rover_env_fused.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/rover_env_fused.py:        # Replace inf values with max_lidar_range
sb3/environments/rover_env_fused.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/rover_env_fused.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/rover_env_fused.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/rover_env_fused.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/rover_env_fused.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/rover_env_fused.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/rover_env_fused.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/rover_env_fused.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/rover_env_fused.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/rover_env_fused.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/rover_env_fused.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/rover_env_fused.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/rover_env_fused.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/rover_env_fused.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/rover_env_fused.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/rover_env_fused.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
sb3/environments/rover_env_fused.py:        # Check for lidar data since we still need it for rewards
sb3/environments/rover_env_fused.py:            if len(self.lidar_data) > 0 and np.any(self.lidar_data > 0):
sb3/environments/rover_env_test.py:                 connection_check_timeout=30, lidar_points=32, max_lidar_range=12.0):
sb3/environments/rover_env_test.py:        self.lidar_points = lidar_points
sb3/environments/rover_env_test.py:        self.max_lidar_range = max_lidar_range
sb3/environments/rover_env_test.py:        self.lidar_data = np.zeros(self.lidar_points, dtype=np.float32)
sb3/environments/rover_env_test.py:        self.min_raw_lidar = 100
sb3/environments/rover_env_test.py:            'lidar': spaces.Box(
sb3/environments/rover_env_test.py:                high=max_lidar_range,
sb3/environments/rover_env_test.py:                shape=(lidar_points,),
sb3/environments/rover_env_test.py:        self.lidar_subscriber = self.node.create_subscription(
sb3/environments/rover_env_test.py:            self.lidar_callback,
sb3/environments/rover_env_test.py:            'lidar': self.lidar_data,
sb3/environments/rover_env_test.py:        min_distance = np.min(self.lidar_data[np.isfinite(self.lidar_data)])
sb3/environments/rover_env_test.py:    def lidar_callback(self, msg):
sb3/environments/rover_env_test.py:            lidar_data = np.array(msg.ranges, dtype=np.float32)
sb3/environments/rover_env_test.py:        #if np.any(np.isneginf(lidar_data)):
sb3/environments/rover_env_test.py:        #    print(f"WARNING: Found {np.sum(np.isneginf(lidar_data))} negative infinity values")
sb3/environments/rover_env_test.py:        if np.any(np.isnan(lidar_data)):
sb3/environments/rover_env_test.py:            print(f"WARNING: Found {np.sum(np.isnan(lidar_data))} NaN values")
sb3/environments/rover_env_test.py:        #if np.any(lidar_data < 0):
sb3/environments/rover_env_test.py:        #    print(f"WARNING: Found {np.sum(lidar_data < 0)} negative values")
sb3/environments/rover_env_test.py:            #print("Negative values:", lidar_data[lidar_data < 0])
sb3/environments/rover_env_test.py:        #gaussian_noise = np.random.normal(0, 0.05, size=lidar_data.shape)  # 0.1m standard deviation
sb3/environments/rover_env_test.py:        #lidar_data = lidar_data + gaussian_noise
sb3/environments/rover_env_test.py:        #dropout_mask = np.random.random(lidar_data.shape) < 0.05  # 5% chance of dropout
sb3/environments/rover_env_test.py:        #lidar_data[dropout_mask] = self.max_lidar_range
sb3/environments/rover_env_test.py:        # Replace inf values with max_lidar_range
sb3/environments/rover_env_test.py:        inf_mask = np.isinf(lidar_data)
sb3/environments/rover_env_test.py:            #print(f"INFO: Replaced {np.sum(inf_mask)} infinity values with max_lidar_range")
sb3/environments/rover_env_test.py:            lidar_data[inf_mask] = self.max_lidar_range
sb3/environments/rover_env_test.py:        invalid_mask = np.logical_or(np.isnan(lidar_data), lidar_data < 0)
sb3/environments/rover_env_test.py:            print(f"INFO: Replaced {np.sum(invalid_mask)} invalid values with max_lidar_range")
sb3/environments/rover_env_test.py:            lidar_data[invalid_mask] = self.max_lidar_range
sb3/environments/rover_env_test.py:        lidar_data = np.clip(lidar_data, 0, self.max_lidar_range)
sb3/environments/rover_env_test.py:        expected_points = self.lidar_points * (len(lidar_data) // self.lidar_points)
sb3/environments/rover_env_test.py:            print(f"ERROR: Not enough LIDAR points for downsampling. Got {len(lidar_data)} points")
sb3/environments/rover_env_test.py:            segment_size = len(lidar_data) // self.lidar_points
sb3/environments/rover_env_test.py:            reshaped_data = lidar_data[:segment_size * self.lidar_points].reshape(self.lidar_points,
sb3/environments/rover_env_test.py:            self.lidar_data = np.min(reshaped_data, axis=1)
sb3/environments/rover_env_test.py:            if len(self.lidar_data) != self.lidar_points:
sb3/environments/rover_env_test.py:                print(f"ERROR: Downsampled has wrong size. Expected {self.lidar_points}, got {len(self.lidar_data)}")
sb3/environments/rover_env_test.py:            if np.any(np.isnan(self.lidar_data)) or np.any(np.isinf(self.lidar_data)):
sb3/environments/rover_env_test.py:                print("NaN count:", np.sum(np.isnan(self.lidar_data)))
sb3/environments/rover_env_test.py:                print("Inf count:", np.sum(np.isinf(self.lidar_data)))
rover_metrics/rover_metrics/metrics_node.py:        self.lidar_subscription = self.create_subscription(
rover_metrics/rover_metrics/metrics_node.py:            self.lidar_callback,
rover_metrics/rover_metrics/metrics_node.py:    def lidar_callback(self, msg):
rover_metrics/rover_metrics/bak/metrics_node.py:        self.lidar_subscription = self.create_subscription(
rover_metrics/rover_metrics/bak/metrics_node.py:            self.lidar_callback,
rover_metrics/rover_metrics/bak/metrics_node.py:    def lidar_callback(self, msg):
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:    if accessories_config.get('rplidar', {}).get('ros__parameters', {}).get('active', False):
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:        lidar_node = Node(
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:            package='rplidar_ros',
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:            executable='rplidar_composition',
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:            name='rplidar',
roverrobotics_ros2/roverrobotics_driver/launch/accessories.launch.py:        ld.add_action(lidar_node)
